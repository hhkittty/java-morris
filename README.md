# java-morris

## 개요

### 결정 배경 및 동기
- **재도전의 의미**: 과거에 게임 로직의 복잡성으로 인해 구현을 포기했던 경험이 있습니다. 최근 3주간의 학습 경험과 2주의 개발 기간이라면 충분히 도전해볼 만하다고 판단하여 프로젝트 주제로 재선정했습니다.


- **기술적 목표**: 졸업 과제에서 Python Socket 통신 경험을 바탕으로, Java의 Socket 프로그래밍을 활용하여 실시간 통신 환경을 구축하고, 멀티스레딩 환경에서의 게임 상태 동기화를 성공적으로 구현하는 것을 목표로 하였습니다.
### 과제 목표:

- MVC 패턴을 엄격하게 적용하여 게임 로직(Model)과 UI(View), 네트워크 통신(Controller)을 완벽하게 분리하는 구조를 확립합니다.


- 두 명의 클라이언트가 서버를 통해 게임 상태를 실시간으로 동기화할 수 있도록 구현합니다.


- 밀(Mill) 생성 및 제거 규칙을 포함한 핵심 게임 규칙을 완전하게 구현하는 것입니다.

### 한계점
- **단일 세션**: 현재 서버는 한 번에 오직 두 명의 플레이어만을 받아 운영할 수 있습니다. 동시에 여러 쌍이 게임을 할 수 없습니다.


- **네트워크 접근성 제한**: 현재 서버는 개인 환경에서 실행되고 있으며, 방화벽 및 공유기 포트 포워딩 설정 문제로 인해 같은 네트워크(LAN) 환경에 있는 클라이언트만 접속 가능합니다. 외부(WAN) 네트워크를 통한 접속은 현재 보장되지 않습니다.


- **예외 처리**: 네트워크 연결이 불안정하거나 예기치 못한 종료 상황 발생 시, 클라이언트와 서버가 정상적으로 종료되지 않는 예외 처리 부분이 아직 미흡합니다.
---
## 나인맨스모리스 규칙
나인 맨스 모리스는 24개의 노드로 이루어진 보드 위에서 두 명의 플레이어가 각각 9개의 돌을 가지고 진행하는 고대 전략 게임입니다.

### 1. 게임의 3단계

#### 돌 놓기 단계 (Placing Phase):

- 각 플레이어가 번갈아 가며 9개의 돌을 보드의 빈 노드에 하나씩 놓습니다.
- 이 단계에서 돌을 놓아 밀(Mill)을 만들면 상대방의 돌을 제거할 수 있습니다.

#### 이동 단계 (Moving Phase):

- 모든 돌(총 18개)을 놓은 후 시작됩니다.
- 플레이어는 자신의 돌을 인접한 빈 노드로 한 칸씩 이동시킬 수 있습니다.

#### 비행 단계 (Flying/Jumping Phase):
- 자신의 돌이 3개만 남았을 때 시작됩니다.
- 플레이어는 자신의 돌을 인접 노드에 관계없이 보드의 아무 빈 노드로 이동(점프)시킬 수 있습니다.

### 2. 밀(Mill)과 제거 규칙
- **밀(Mill) 생성**: 자신의 돌 3개를 수평 또는 수직선상에 연속으로 놓았을 때 '밀'이 생성됩니다.

- **상대방 돌 제거**: 밀을 생성한 플레이어는 즉시 상대방의 돌 중 밀에 포함되지 않은 돌 하나를 선택하여 보드에서 제거할 수 있습니다.

### 3. 승리 조건
다음 조건 중 하나를 먼저 달성한 플레이어가 승리합니다.

- 상대방의 돌이 2개 이하로 남았을 때.

- 상대방이 합법적인 이동을 할 수 없을 때 (모든 돌이 막혔을 때).
----------
## 프로그램 기능 및 흐름
### 네트워크 및 컨트롤러 흐름
- 서버 실행 (MorrisServer): 9000번 포트를 열고 2명의 클라이언트 접속을 기다립니다. 2명이 접속하면 게임을 시작합니다.

- 클라이언트 핸들링 (PlayerHandler): 각 클라이언트마다 별도의 스레드가 할당되어 통신을 관리합니다.

- 입력 전송: 클라이언트가 노드를 클릭하면 (BoardView → MorrisClient), 클릭 인덱스가 GameMove 객체에 담겨 서버로 전송됩니다.

###  서버 로직 
서버는 클라이언트로부터 입력(클릭 인덱스)을 받을 때마다 현재 **GamePhase**를 확인하고 해당 로직을 순서대로 처리합니다.

#### 1. 돌 놓기 단계 (Placing Phase)
- 플레이어가 빈 노드를 클릭하여 돌을 놓으면 로직이 시작됩니다.

- 서버는 해당 위치가 유효한지 확인하고 돌을 배치합니다.

- 배치 후, **밀**(**Mill**)이 생성되었는지 확인합니다.

- 밀이 생성되었다면, 페이즈를 REMOVE로 전환하고 상대방의 돌 제거를 기다립니다.

- 밀이 생성되지 않았다면, 턴을 상대방에게 넘깁니다.

- 모든 돌(9개)을 다 놓았다면 다음 페이즈인 MOVING으로 전환합니다.

#### 2. 이동 단계 (Moving Phase)
- 플레이어가 옮길 돌과 옮길 위치를 순차적으로 선택합니다.

- 선택한 돌이 내 돌인지 확인합니다.

- 옮길 위치가 빈 칸이며, 현재 돌의 위치와 이웃한 칸인지 확인합니다.

- 유효성 검사를 통과하여 돌 이동에 성공하면, 밀 생성 여부를 확인합니다.

- 밀이 생성되었다면 REMOVE로 전환하고, 아니면 턴을 상대방에게 넘깁니다.

#### 3. 제거 단계 (Remove Phase)
- 밀을 만든 플레이어는 상대방의 돌을 제거하기 위해 상대방 돌 중 하나를 클릭합니다.

- 선택한 돌이 상대방의 돌인지, 그리고 그 돌이 밀에 포함되지 않은 돌인지 확인합니다. (단, 상대방의 모든 돌이 밀에 포함된 경우(Double Mill)에는 예외적으로 밀 안의 돌도 제거 가능합니다.)

- 돌 제거에 성공하면, 상대방의 남은 돌 개수를 확인하여 다음 단계를 결정합니다.

- 상대방 돌이 3개 남았다면, 상대방의 다음 턴 페이즈를 JUMP로 설정합니다.

- 상대방 돌이 3개 미만으로 남았다면 패배를 선언하고 게임을 종료합니다.

- 위의 조건이 아니라면, 이전 페이즈(MOVING)로 돌아가며 턴을 상대방에게 넘깁니다.
#### 4. 비행 단계 (Jump Phase)
- 자신의 돌이 3개만 남은 플레이어에게 적용되는 이동 방식입니다.

- 옮길 돌 선택 후, 옮길 위치를 선택합니다.

- 내 돌인지 확인하고, 옮길 위치가 빈 칸인지만 확인합니다. (이웃한 칸일 필요는 없습니다.)

- 이동에 성공하면 MOVING 단계와 동일하게 밀 생성 여부를 확인하여, 밀이 생성되었다면 REMOVE로 전환하고 아니면 턴을 상대방에게 넘깁니다.

### ️ 클라이언트와 뷰 갱신
- 메시지 수신: 클라이언트 (MorrisClient)는 서버로부터 메시지(예: Move Success:, Mill, TURN:)를 수신합니다.

- 로컬 업데이트: 수신한 메시지를 파싱하여 로컬의 GameBoard 객체를 업데이트합니다.

- 화면 갱신: BoardView의 repaint()를 호출하여 변경된 GameBoard 상태에 맞게 화면을 다시 그립니다.